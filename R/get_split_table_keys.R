#' Retrieve the customer table keys which can be used to split table on.
#' @param customer_tables a list of data.frames where each element corresponds to a
#' specific customer table, based on their field list information
#' @param key_lookup_table character vector corresponding to a table within `customer_tables`
#' from which the keys will be obtained.
#' @param split_key_field the filed within a customer table from which the keys will be retrieved.
#' @return character vector of keys which will be used to split a dictionary table
.get_split_keys = function(customer_tables, key_lookup_table,
                           split_key_field = "display_name"){

   if(!key_lookup_table %in% names(customer_tables)) stop("key_lookup_table not found in customer_tables",call. = T)

   if(!split_key_field %in%  names(customer_tables[[key_lookup_table]])) stop("split_key_field not found in key_lookup_table", call. = T)

    out_keys = customer_tables[[key_lookup_table]][[split_key_field]]

    return(out_keys)

}


#' Retrieve the customer table keys which can be used to split table on.
#' @param customer_tables a list of data.frames where each element corresponds to a
#' specific customer table, based on their field list information
#' @param tbls_to_split character vector corresponding to a table within `customer_tables`
#' from which the keys will be obtained.
#' @param split_key_field the filed within a customer table from which the keys will be retrieved.
#' @return character vector of keys which will be used to split a dictionary table
.get_all_split_keys = function(tbls_to_split, customer_tables,
                               split_key_field = "display_name"){

    key_lookup_tbls = unlist(tbls_to_split[["customer"]])

    if(length(key_lookup_tbls) > 1){

        out_keys = vector("list", length = length(key_lookup_tbls))

        for (table in seq_along(key_lookup_tbls)){

            out_keys[[table]] =  .get_split_keys(customer_tables = customer_tables,
                                                 key_lookup_table = key_lookup_tbls[[table]],
                                                 split_key_field = split_key_field)

            names(out_keys)[[table]] = key_lookup_tbls[[table]]
        }

    }else{
        out_keys = list(.get_split_keys(customer_tables = customer_tables,
                                        key_lookup_table = key_lookup_tbls,
                                        split_key_field = split_key_field))
        names(out_keys) = key_lookup_tbls
        }

    return(out_keys)
}




#' Retrieve the customer table keys which can be used to split table on.
#' @param tables_to_split List of customer and corresponding dictionary tables to
#' split returned from `find_cancer_tables`
#' @param customer_tables a list of data.frames where each element corresponds to a
#' specific customer table, based on their field list information
#' @param dictionary_tables a list of data.frames where each element corresponds
#' to a specific data dictionary table
#' @param split_key_field the field within a customer table from which the keys will be retrieved
#' @return List with the same dimensions as the `tables_to_split` input with
#' keys replacing the customer table names.
get_split_keys = function(tables_to_split,
                          customer_tables,
                          dictionary_tables,
                          split_key_field = "display_name"){

    found = tables_to_split

    # Add dd table character copy so it can be used when creating the split df's
    found = lapply(found, function(x){
        x$dd_split_tbl = x$dd
        return(x)

    })

    out = vector("list", length = length(found))

    for (table in seq_along(found)) {

        out[[table]] = .get_all_split_keys(tbls_to_split = found[[table]] ,
                                            customer_tables = customer_tables,
                                            split_key_field = split_key_field)
        }

    for (dataset in seq_along(out)) {

        found[[dataset]][["customer"]] = out[[dataset]]

        found[[dataset]][["dd"]] = dictionary_tables[[found[[dataset]][["dd"]]]][[split_key_field]]

    }

    return(found)

}


#' check for missing keys between a customer table and a dictionary table
#' @param split_lookup a list of lookup keys generated by `get_split_keys`
.check_for_missing_keys = function(split_lookup){

    out = vector("list", length(split_lookup[["customer"]]))

    for (i in seq_along(split_lookup[["customer"]])) {

        out[[i]]$found = intersect(tolower(split_lookup[["customer"]][[i]]), tolower(split_lookup[["dd"]]))

        out[[i]]$missing = setdiff(tolower(split_lookup[["customer"]][[i]]), tolower(split_lookup[["dd"]]))

        names(out)[[i]] = names(split_lookup[["customer"]])[[i]]

    }

    for (i in seq_along(out)) {

        if(length(out[[i]][["missing"]]) > 0){

            out[[i]] = out[[i]][["missing"]]

        }else out[[i]] = TRUE

    }

    return(out)

}

#' Identify missing split keys between customer and dictionary tables
#' @param split_lookup_keys a list of lookup keys generated by `get_split_keys`
#' @return List of length `split_lookup_keys` a logical of length 1, equalling
#' FALSE to denote that there are no missing keys in the split keys lookup
#'
#' OR
#'
#' a list of character vectors, one for each set lookup tables, which displays any
#' keys which are missing between the customer table and the corresponding
#' dictionary table
missing_split_keys = function(split_lookup_keys){

    out = vector("list", length(split_lookup_keys))

    for (lookup in seq_along(split_lookup_keys)) {

        out[[lookup]] =  .check_for_missing_keys(split_lookup_keys[[lookup]])

        names(out)[[lookup]] = names(split_lookup_keys)[[lookup]]

    }

    out = out %>% purrr::map(~purrr::keep(.x, ~!is.logical(.x)))

    if(all(lengths(out) == 0)) out = FALSE

    return(out)

}

